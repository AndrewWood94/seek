require 'test_helper'
require 'sessions_controller'

# Re-raise errors caught by the controller.
class SessionsController; def rescue_action(e)
                            raise e
                          end; end

class SessionsControllerTest < ActionController::TestCase
  # Be sure to include AuthenticatedTestHelper in test/test_helper.rb instead
  # Then, you can remove it from this and the units test.
  include AuthenticatedTestHelper

  fixtures :users, :people

  def setup
    Seek::Config.omniauth_providers = {
      ldap: {
        title: 'organization-ldap',
        host: 'localhost',
        port: 389,
        method: :plain,
        base: 'DC=example,DC=com',
        uid: 'samaccountname',
        password: '',
        bind_dn: ''
      }
    }

    # add an omniauth user
    auth_hash = {
      provider: 'ldap',
      uid: 'new_ldap_user',
      info: { 'nickname' => 'new_ldap_user', 'first_name' => 'new', 'last_name' => 'ldap_user', 'email' => 'new_ldap_user@example.com' }
    }
    OmniAuth.config.add_mock(:ldap, auth_hash)
  end

  test 'sessions#index redirects to session#new' do
    get :index
    assert_redirected_to root_path
  end

  test 'session#show redirects to root page' do
    get :show
    assert_redirected_to root_path
  end

  test 'index_not_logged_in' do
    get :new
    assert_response :success

    User.destroy_all # remove all users
    assert_equal 0, User.count
    get :new
    assert_response :redirect
    assert_redirected_to signup_url
  end

  test 'title' do
    get :new
    assert_select 'title', text: 'Login', count: 1
  end

  test 'should log in with username' do
    post :create, params: { login: users(:quentin).login, password: 'test' }
    assert session[:user_id]
    assert_response :redirect
  end

  test 'should log in with email' do
    post :create, params: { login: users(:quentin).person.email, password: 'test' }
    assert session[:user_id]
    assert_response :redirect
  end

  # FIXME: check whether doing a redirect is a problem - this is a test generated by the restful_auth.. plugin, so is clearly there for a reason
  #  test 'should_fail_login_and_not_redirect' do
  #    post :create, :login => 'quentin', :password => 'bad password'
  #    assert_nil session[:user_id]
  #    assert_response :success
  #  end

  test 'should_logout' do
    login_as :quentin
    @request.env['HTTP_REFERER'] = '/data_files'
    get :destroy
    assert_nil session[:user_id]
    assert_response :redirect
  end

  test 'should_remember_me' do
    post :create, params: { login: 'quentin', password: 'test', remember_me: 'on' }
    assert_not_nil @response.cookies['auth_token']
  end

  test 'should_not_remember_me' do
    post :create, params: { login: 'quentin', password: 'test', remember_me: 'off' }
    assert_nil @response.cookies['auth_token']
  end

  test 'should_delete_token_on_logout' do
    login_as :quentin
    @request.env['HTTP_REFERER'] = '/data_files'
    get :destroy
    assert_nil @response.cookies['auth_token']
  end

  test 'should_login_with_cookie' do
    users(:quentin).remember_me
    @request.cookies['auth_token'] = cookie_for(:quentin)
    get :new
    assert @controller.send(:logged_in?)
  end

  test 'should_fail_expired_cookie_login' do
    users(:quentin).remember_me
    users(:quentin).update_attribute :remember_token_expires_at, 5.minutes.ago
    @request.cookies['auth_token'] = cookie_for(:quentin)
    get :new
    assert !@controller.send(:logged_in?)
  end

  test 'should_fail_cookie_login' do
    users(:quentin).remember_me
    @request.cookies['auth_token'] = 'invalid_auth_token'
    get :new
    assert !@controller.send(:logged_in?)
  end

  test 'non_activated_user_should_redirect_to_new_with_message' do
    user = Factory(:brand_new_user, person: Factory(:person))
    post :create, params: { login: user.login, password: user.password }
    assert !session[:user_id]
    assert_redirected_to login_path
    assert_not_nil flash[:error]
    assert flash[:error].include?('You still need to activate your account.')
  end

  test 'partly_registed_user_should_redirect_to_select_person' do
    user = Factory(:brand_new_user)
    post :create, params: { login: user.login, password: user.password }
    assert session[:user_id]
    assert_equal user.id, session[:user_id]
    assert_not_nil flash.now[:notice]
    assert_redirected_to register_people_path
  end

  test 'should redirect to root after logging out from the search result page' do
    login_as :quentin
    @request.env['HTTP_REFERER'] = 'http://test.host/search/'
    get :destroy
    assert_redirected_to :root
  end

  test 'should redirect to back after logging out from the page excepting search result page' do
    login_as :quentin
    @request.env['HTTP_REFERER'] = 'http://test.host/data_files/'
    get :destroy
    assert_redirected_to 'http://test.host/data_files/'
  end

  test 'should redirect to root after logging in from the search result page' do
    @request.env['HTTP_REFERER'] = 'http://test.host/search'
    post :create, params: { login: 'quentin', password: 'test' }
    assert_redirected_to :root
  end

  test 'should redirect to back after logging in from the page excepting search result page' do
    @request.env['HTTP_REFERER'] = 'http://test.host/data_files/'
    post :create, params: { login: 'quentin', password: 'test' }
    assert_redirected_to 'http://test.host/data_files/'
  end

  test 'should redirect to given path' do
    post :create, params: { login: 'quentin', password: 'test', called_from: { path: '/data_files' } }
    assert session[:user_id]
    assert_redirected_to data_files_path
  end

  test 'should not redirect to external url' do
    post :create, params: { login: 'quentin', password: 'test', called_from: { path: 'http://not.our.domain/data_files' } }

    assert session[:user_id]

    assert_not_includes @response.location, 'not.our.domain'
    assert_includes @response.location, 'test.host'
  end

  test 'should have only seek login' do
    with_config_value(:omniauth_enabled, false) do
      get :new
      assert_response :success
      assert_select 'title', text: 'Login', count: 1
      assert_select '#login-panel form', 1
    end
  end

  test 'should have provider login' do
    # change the setting
    with_config_value(:omniauth_enabled, true) do
      with_config_value(:elixir_aai_client_id, 'xxx') do
        with_config_value(:elixir_aai_secret, 'yyy') do
          Devise.setup do |config|
            config.omniauth :ldap, name: :ldap,
                            title: 'organization-ldap',
                            host: 'localhost',
                            port: 389,
                            method: :plain,
                            base: 'DC=example,DC=com',
                            uid: 'samaccountname',
                            password: '',
                            bind_dn: ''
          end

          assert Devise.omniauth_providers.include? :ldap

          get :new
          assert_response :success

          assert_select '#login-panel li', Devise.omniauth_providers.length + 1

          # LDAP login is known about
          assert_select '#login-panel div[id="ldap_login"]', 1

          # No login specified for LDAP
          assert_select '#login-panel div[class="alert alert-danger"]', 1
        end
      end
    end
  end

  test 'should not create omni authenticated user' do
    # change the setting
    with_config_value(:omniauth_enabled, true) do
      with_config_value(:omniauth_user_create, false) do
        @request.env['omniauth.auth'] = OmniAuth.config.mock_auth[:ldap]

        post :create
        assert_redirected_to login_path
        assert_match(/the authenticated user: cannot be found/, flash[:error])
        assert_nil User.find_by_login('new_ldap_user')
      end
    end
  end

  test 'should create omni authenticated user' do
    # change the setting
    with_config_value(:omniauth_enabled, true) do
      with_config_value(:omniauth_user_create, true) do
        @request.env['omniauth.auth'] = OmniAuth.config.mock_auth[:ldap]

        post :create
        assert_redirected_to login_path
        assert_match(/You need to login directly to link accounts/, flash[:notice])
      end
    end
  end

  protected

  def cookie_for(user)
    users(user).remember_token
  end
end
